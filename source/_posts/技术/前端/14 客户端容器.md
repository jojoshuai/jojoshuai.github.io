---
title: 14 客户端容器
date: 2024-08-01 16:40:41
categories:
  - 前端
tags:
  - 前端
  - 浏览器
---

from https://bytetech.info/videos/set/7193722320643424311/7197637182679416888

# 客户端容器 - web 浏览器以及跨端方案

## 1. 浏览器架构

### 1.1 浏览器架构演进

- 浏览器架构
  ![浏览器架构](/images/js浏览器架构.png)
- 浏览器架构对比
  ![浏览器架构对比](/images/浏览器架构对比.png)

### 1.2 浏览器内的进程

- 任务管理器
  - 在 chrome 中，选择 更多工具 - 任务管理器 可查看
  - 每一个都是一个进程
- 多进程分工
  - 浏览器主进程：
    - 负责页面展示逻辑，用户交互，
    - 子进程管理：包括地址栏、书签、前进、后退、收藏夹等
  - GPU 进程：负责 UI 绘制，包括整个浏览器的全部 UI
  - 网络进程：负责网络资源加载
  - 标签页(渲染进程)‼️ ：控制 tab 内的所有内容，将 html、css 和 javascript 转换为用户可交互的网页
  - 插件进程: 如 flash、modheader
  - 其他进程：如 storage/network/audio service

## 2. 渲染进程

### 2.1 常见浏览器内核

![常见浏览器内核](/images/常见浏览器内核.png)

### 2.2 渲染进程

内部是多线程实现，主要负责页面渲染，脚本执行，事件处理，网路请求等
![浏览器的渲染进程](/images/浏览器的渲染进程.png)

### 2.3 js 引擎和渲染引擎

1. v8 作为 js 的引擎，会讲一些常用的字节码转化为机器码直接执行，进而提升 js 的执行效率
2. 使用 js 操作 dom 的时候，需要将数据通过 bridge 传输到渲染引擎中，故大批量操作必然会有卡顿

## 2.4 多线程工作流程

![多线程工作流程](/images/多线程工作流程.png)

```js
const now = Date.now()

setTimeout(() => {
    console.log('time10', Date.now() - now) // 输出？？
}, 1000)

setTimeout(() => {
    console.log('time30', Date.now() - now) // 输出？？
}, 3000)

while (true) {
    if (Date.now() - now >= 2000) {
        break
    }
}

console.log(Date.now - now)

// node test.js
// output:
// 2000
// time10 2005
// time30 3002
> 1. js的setTimeout有延迟，每次事件循环有4ms左右的偏差
> 2. setTimeout(定时器线程)会将func放到任务队列中
> 3. 故上述代码：
> 4.  会优先执行循环while循环，等到while结束，console.log输出 2000
> 5.  同时去看任务队列，发现任务队列中有一个console.log，故输出 2005
> 6.  然后等待第二个setTimeout，输出 3002

```

## 3. Chrome 运行原理

### 3.1 如何展示网页

- 浏览器地址输入 URL 后发生了什么
  ![浏览器地址输入URL后发生了什么](/images/浏览器地址输入URL后发生了什么.png)
  IPC： 进程间通讯

1.  输入处理
    1. 用户的 url 输入内容后，UI 线程会判断输入的是一个 URL 地址，还是一个 query 查询条件
    2. 如果是 url，则直接请求站点资源
    3. 如果是 query，将输入发送给搜索引擎
2.  开始导航
    1. 当用户按下回车键之后，UI 线程通知网络线程发起一个网络请求，来获取站点内容
    2. 请求过程中，tab 处于 loading 状态
3.  读取响应
    1. **网络线程**接收到 http 响应后，先检查响应头的媒体类型(MIME type)
    2. 如果响应主题是一个 HTML 文件，浏览器将内容交给渲染进程处理
    3. 如果拿到的是其他类型文件，比如 zip、exe 等，则交给下载管理器处理
4.  寻找渲染进程
    1. 网络线程做完所有检查后，会告知主进程(浏览器)数据已准备完毕，主进程确认后为这个站点寻找一个渲染进程
    2. 主进程通过 IPC 消息告知渲染进程去处理本次导航
    3. 渲染进程开始接收数据并告知主进程自己已经开始处理，导航结束，进入文档加载阶段
5.  渲染进程：资源加载
    1. 收到主进程消息后，开始加载 html 文档
    2. 除此之外，还需要加载子资源，比如一些图片，css 样式文件以及 javascript 脚本
6.  渲染进程：构建渲染树
    1. 构建 DOM 树，将 HTML 文本转化成浏览器能够理解的结构
    2. 构建 CSSOM 树，浏览器同样不认识 CSS，故需将 CSS 代码转化为可理解的 CSSOM
    3. 构建渲染树，渲染树是 DOM 树和 CSSOM 树的结合
       ![构建渲染树](/images/构建渲染树.png)
7.  渲染进程：页面布局
    1. 根据渲染树计算每个节点的位置和大小
    2. 在浏览器页面区域绘制元素边框
    3. 遍历渲染树，将元素以盒模型的形式写入文档流
8.  渲染进程：页面绘制
    1. 构建图层：为特定的节点声称专用图层
    2. 绘制图层：一个图层分成很多绘制指令，然后将这些指令按顺序组成一个绘制列表，交给合成线程 (这里可以理解为绘制指令=画画画中的一笔，而合成后则是告诉其连续画几笔)
    3. 合成线程接收指令声称图块
    4. 删格线程将图块进行删格化 (此处就会调用 gpu 进行处理)
    5. 展示在屏幕上

### 3.2 前端性能 performance

    3.2.1. chrome performance介绍
    3.2.2 首屏优化
        1. 压缩、分包、删除无用代码
        2. 静态资源分离
        3. js脚本非阻塞加载
        4. 缓存策略 (js直接使用长缓存)
        5. SSR （服务端渲染）
        6. 预置loading、骨架屏
    3.2.3 渲染优化
        1. gpu加速
        2. 减少回流、重绘
        3. 离屏渲染
        4. 懒加载
    3.2.3 js优化
        1. 内存泄漏，合理使用定时器
        2. 循环内尽早break
        3. 合理使用闭包
        4. 减少dom访问
        5. 防抖、节流
        6. 使用web workers：独立于js的进程，可以和js进程一起工作

## 4. 跨端容器

### 4.1 为什么需要跨端

1. 开发成本、效率
2. 一致性体验
3. 前端开发生态

### 4.2 有哪些跨端方案

1. webview
   - 即网页时图，用于加载网页 URL，并展示其内容的控件
   - 可以内嵌在移动端的 app 内，实现前端混合开发，大多数混合框架都是基于 webview 的二次开发；比如 Ionic, Cordova， Uniapp
   - webview 优势：
     - 一次发布，处处使用，成本低
     - 随时发布，即时更新，不用下载安装包
     - 通过 jsbridge 和原生系统交互，实现复杂功能
   - webview 和原生的交互
     1. js 调用 native: api 注入；使用 webview URL scheme 跳转拦截；ios 可以使用 window.webkit.messageHandler 直接通信
     2. native 调用 js: 直接通过 webview 暴露的 api 执行 js 代码；
        - ios webview.stringByEvaluatingJavaScriptFromString;
        - andriod webview.evaluateJavascript
     3. jsbridge 是对上述方式的封装
2. 小程序
3. ReactNative / Weex
4. Lynx
   字节内部的；基于 vue + jsbinding
5. Flutter

### 4.3 跨端容器-通用原理

![跨端容器-通用原理](/images/跨端容器-通用原理.png)

### 4.4 跨端方案对比

![跨端方案对比](/images/跨端方案对比.png)
